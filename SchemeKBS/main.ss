;;;;; Main file for the entity semantic information extraction product

(define (process-file fpath)
  (process-string (file->string fpath)))

(define (process-string str)
  (define (list-sort x)
    (define (test123 x y)
      (> (cadr x) (cadr y)))
    (sort x test123))
  (let* ((words (words-from-string str))
	 (num (vector-length words))
	 (no-noise-words (no-noise words))
	 (tags (parts-of-speech words))
	 (1-gram (make-table size: 1000))
	 (2-grams (make-table size: 1000))
	 (3-grams (make-table size: 1000))
	 (4-grams (make-table size: 1000))
	 (key-phrase-list '())
	 (summary-words '())
	 (proper-name-list (find-human-names words '()))
	 (place-list '())
	 (num-cat-hash-tables (length categoryHashtables))
	 (category-seq (make-vector num-cat-hash-tables))
	 (word #f) (cat-hash #f) (x #f))
    ;; build n-grams:
    (for (n (in-range (- num 3)))
	 (if (not (noise-word? (vector-ref words n)))
	     (let* ((1-s (vector-ref words n))
		    (2-s (string-append 1-s " " (vector-ref words (+ n 1))))
		    (3-s (string-append 2-s " " (vector-ref words (+ n 2))))
		    (4-s (string-append 3-s " " (vector-ref words (+ n 3)))))
	       (table-set! 1-gram 1-s (+ 1 (table-ref 1-gram 1-s 0)))
	       (if (not (noise-word? (vector-ref words (+ 1 n))))
		   (begin
		     (table-set! 2-grams 2-s (+ 1 (table-ref 2-grams 2-s 0)))
		     (if (not (noise-word? (vector-ref words (+ 2 n))))
			 (begin
			   (table-set! 3-grams 3-s (+ 1 (table-ref 3-grams 3-s 0)))
			   (if (noise-word? (vector-ref words (+ 3 n)))
			       (table-set! 4-grams 4-s (+ 1 (table-ref 4-grams 4-s 0)))))))))))
    (table-for-each ; 2-grams:
     (lambda (k v) (if (> v 1) (set! key-phrase-list (cons k key-phrase-list))))
     2-grams)
    (table-for-each ; 3-grams:
     (lambda (k v) (if (> v 1) (set! key-phrase-list (cons k key-phrase-list))))
     3-grams)
    (table-for-each ; 4-grams:
     (lambda (k v) (if (> v 1) (set! key-phrase-list (cons k key-phrase-list))))
     4-grams)
    
    (do ((k 0 (+ k 1)))
	((equal? k num))
      (set! word (string-downcase (vector-ref words k)))
      (do ((i 0 (+ i 1)))
	  ((equal? i num-cat-hash-tables))
	(set! cat-hash (list-ref categoryHashtables i))
	(set! x (table-ref cat-hash word  #f))
	(if x
	    (vector-set! category-seq i (+ (vector-ref category-seq i) x)))))
    (let ((ss '()))
      (do ((i 0 (+ i 1)))
	  ((equal? i num-cat-hash-tables))
	(if (> (vector-ref category-seq i) 0.01)
	    (set! ss (cons (list (list-ref categoryNames i) (round (* (vector-ref category-seq i) 10))) ss))))
      (set! ss (list-sort ss))
      (set! x (round (+ (/ (length ss) (/ num-cat-hash-tables 3)) 1)))
      (set! category-seq'())
      (set! num-cat-hash-tables (length ss))
      (do ((i 0 (+ i 1)))
	  ((equal? i num-cat-hash-tables))
	(set! category-seq (cons (list-ref ss i) category-seq))))
    
    (set! category-seq (reverse category-seq))
    (list words tags key-phrase-list (list (car category-seq) (cadr category-seq)) summary-words proper-name-list place-list)))

;;(process-file "data/testdata/climate_g8.txt")

